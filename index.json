[
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/ecosystem/tools/",
	"title": "Tools",
	"tags": [],
	"description": "",
	"content": "The VSS can be transformed into other formats or generated as code to integrate with other tooling environments and ecosystems.\nFig 1 shows the schematics of the top-level process.\nFig 1. Generating documents from specification\nSome helpful tools are available in the vss-tools project.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/rule_set/basics/",
	"title": "Basic Rules",
	"tags": [],
	"description": "",
	"content": "Specification format The Vehicle Signal Specification domain specification consist of vspec files. vspec files are YAML files following the rule set defined for VSS. They also support the use of include directives to refer to other vspec files, much like #include in C/C++. . Please note that, from a YAML perspective, the include directive is just another comment.\nThe file VehicleSignalSpecification.vspec serves as root and includes other vspec files from the VSS repository.\nThe raw specification files can, with help of tools in the vss-tools repository, be converted to other formats that are more user friendly to read. Converted representations are also included as release artifacts for each VSS release.\nVSS is in itself case sensitive. This means that keywords, signal names, types and values normally shall be given with the case specified. It is however recommended not to take advantage of this and reuse the same name with different case, as some implementations may treat VSS identifiers as case insensitive.\nAddressing Nodes Tree nodes are addressed, left-to-right, from the root of the tree toward the node itself. Each element in the name is delimited with a period (\u0026quot;.\u0026quot;). The element hops from the root to the leaf is called path.\nFor example, the dimming status of the rearview mirror in the cabin is addressed:\nVehicle.Cabin.RearviewMirror.Dimmed If there are an array of elements, such as door rows 1-3, they will be addressed with an index branch:\nVehicle.Cabin.Door.Row1.Left.IsLocked Vehicle.Cabin.Door.Row1.Left.Window.Position Vehicle.Cabin.Door.Row2.Left.IsLocked Vehicle.Cabin.Door.Row2.Left.Window.Position Vehicle.Cabin.Door.Row3.Left.IsLocked Vehicle.Cabin.Door.Row3.Left.Window.Position In a similar fashion, seats are located by row and their left-to-right position.\nVehicle.Cabin.Seat.Row1.Pos1.IsBelted # Left front seat Vehicle.Cabin.Seat.Row1.Pos2.IsBelted # Right front seat Vehicle.Cabin.Seat.Row2.Pos1.IsBelted # Left rear seat Vehicle.Cabin.Seat.Row2.Pos2.IsBelted # Middle rear seat Vehicle.Cabin.Seat.Row2.Pos3.IsBelted # Right rear seat The exact use of PosX elements and how they correlate to actual positions in the car, is dependent on the actual vehicle using the spec.\nParent Nodes If a new leaf node is defined, all parent branches included in its name must be included as well, as shown below:\n[Signal] Vehicle.Cabin.Door.Row1.Left.IsLocked [Branch] Vehicle.Cabin.Door.Row1.Left [Branch] Vehicle.Cabin.Door.Row1 [Branch] Vehicle.Cabin.Door [Branch] Vehicle.Cabin [Branch] Vehicle The branches do not have to be defined in any specific order as long as each branch component is defined somewhere in the vspec file (or an included vspec file).\nDeprecation since version 2.1 During the process of model development, nodes might be moved or deleted. Giving developers a chance to adopt to the changes, the original nodes are marked as deprecated with the following rules.\nNodes, which are moved in the tree or are intended to be removed from the specification are marked with the deprecation keyword. The string following the deprecation keyword shall start with the version, when the node was deprecated starting with V (e.g. V2.1) followed by the reason for deprecation. If the node was moved, it shall be indicated by moved to followed by the new node name in dot notation as deprecation reason. This keyword shall be used only if the meta-data of the moved node hasn\u0026rsquo;t changed. If the node is intended to be removed from the specification or the meta data changed, it shall be indicated by removed and optionally the reason for the removal as deprecation reason. Nodes which are deprecated will be removed from the specification, either in the second minor update or, if earlier, the next major update. Example Vehicle.Navigation.CurrentLocation: type: branch description: The current latitude and longitude of the vehicle. deprecation: V2.1 moved to Vehicle.CurrentLocation It is recommended for servers, which are implementing protocols for the vehicle signal specification, to serve old and new nodes during the deprecation period described above.\nStyle Guide The VSS specification must adhere to YAML syntax. To keep the standardized VSS specification in this repository consistent the following style guide is provided.\nNaming Conventions The recommended naming convention for node elements is to use camel case notation starting with a capital letter. It is recommended to use only A-Z, a-z and 0-9 in node names. For boolean signals it is recommended to start the name with Is.\nExamples:\nSomeBranch.AnotherBranch.MySignalName Vehicle.Cabin.Door.Row1.Left.IsLocked Naming convention for string literals can be found in the chapterfor specifying allowed values.\nLine Length It is recommended that line length for files in this repository ( e.g. *.vspec and *.md files) shall not exceed 120 characters. This is not a strict limit, it is e.g. not recommended to split long URLs present in files over multiple lines.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/rule_set/branches/",
	"title": "Branch Entry",
	"tags": [],
	"description": "",
	"content": "A branch entry describes a tree branch (or node) containing other branches and signals.\nA branch entry example is given below:\nTrunk: type: branch description: All signals related to the rear trunk aggregate: false The following elements are defined:\nBody.Trunk The list element name defines the dot-notated signal name to the signal. Please note that all parental branches included in the name must be defined as well.\ntype The value branch specifies that this is a branch entry (as opposed to a signal entry). This is the default, in case type is omitted.\ndescription Describes the meaning and content of the branch. Recommended to start with a capital letter and end with a dot (.).\ncomment [optional] since version 3.0 A comment can be used to provide additional informal information on a branch. This could include background information on the rationale for the branch, references to related branches, standards and similar. Recommended to start with a capital letter and end with a dot (.).\ninstances [optional] For specifying that multiple instances of this branch exist, for more information see documentation on instances.\naggregate [optional] Defines whether or not this branch is an aggregate. If not defined, this defaults to false. An aggregate is a collection of signals that make sense to handle together in a system. A typical example could be GNSS location, where latitude and longitude make sense to read and write together. This is supposed to be deployment and tool specific, and for that reason no branches are aggregates by default in VSS. For branches that both have instances defined and aggregate: true, then aggregate refers to the signals for individual instances, i.e. signals for different instances can be handled separately.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/introduction/overview/",
	"title": "Overview",
	"tags": [],
	"description": "",
	"content": "What is VSS? The Vehicle Signal Specification introduces a domain taxonomy for vehicle signals. In short this means that VSS introduces:\nA syntax for defining vehicle signals in a structured manner. A catalog of signals related to vehicles. It can be used as standard in automotive applications to communicate information around the vehicle, which is semantically well defined. It focuses on vehicle signals, in the sense of classical attributes, sensors and actuators with the raw data communicated over vehicle buses and data which is more commonly associated with the infotainment system alike.\nA standardized vehicle data specification allows an industry actor to use a common naming space for communication and, ultimately, abstracts underlying vehicle implementation details.\nWhile the data in the VSS standard catalog aims to be vendor-independent, vendor specific extensions and adaptations complying with the VSS syntax rules can be specified (see Overlays.\nWhat\u0026rsquo;s in Standardized data definition for vehicle signals. Same semantic understanding across different domains. Basic definition for interfaces working on vehicle data (w3c, etc.). What\u0026rsquo;s out Everything outside the vehicle signal domain (customer, weather, etc.). Concrete interface definition. Example The figure below shows an example snapshot of a generated tree of the specification. The leafs contain the actual information as shown in the figure. Before going into detail of the specification, let\u0026rsquo;s dig deeper into taxonomies.\nVSS usage for other domains The VSS catalog focuses on signals related to vehicles. It is not the intention of the VSS project to add signals for other domains. The syntax used for defining VSS signals and related tooling could however be used to define similar signal trees for other domains.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/ecosystem/viss/",
	"title": "W3C-VISS",
	"tags": [],
	"description": "",
	"content": "When using VSS in an automotive tech stack, a question is which protocols and technologies to use to access VSS signals.\nThe W3C Vehicle Information Service Specification (VISS) is an open standard, specifying a protocol to access VSS data via websocket (VISSv1, VISSv2) or HTTP (VISSv2).\nTo learn more check\nVehicle Information Service Specification (VISS) V1 Vehicle Information Service Specification (VISS) V2, still under active development "
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/rule_set/data_entry/",
	"title": "Data Entry",
	"tags": [],
	"description": "",
	"content": "Data Entry Leaf nodes of the tree contain metadata describing the data associated to the node. In order to help application developers, who are using the specification, it makes a distinction between three types of signals - sensor, actuator - and attribute. The difference between sensors/actuators and attributes is that sensors/actuators typically have a publisher (or producer) that updates the signal value continuously when a change occur while an attribute has a set value that should typically not change more than once per ignition cycle.\nExamples and more information you\u0026rsquo;ll find in the Sensors \u0026amp; Actuators chapter and Attributes chapter.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/introduction/taxonomy/",
	"title": "Taxonomies",
	"tags": [],
	"description": "",
	"content": "The figure below explains the idea of a taxonomy as bridge between human and machine understanding of data. It is important to focus on a specific domain to get common understanding and acceptance. The link between two or more domain taxonomies can be seen as second step.\nComponents of a domain taxonomy A domain taxonomy, like VSS, consists of three important components, which will be discussed in detail in this documentation:\n1. Rule Set, as definition on how to describe the data definition syntactically.\n2. Data Definition, as description of the domain as a simple graph.\n3. Tools and Serialization, generates the serialization out of the data Definition for further usage.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/ecosystem/software/",
	"title": "Software",
	"tags": [],
	"description": "",
	"content": "Various software frameworks exist to work with VSS data. If something is missing here, please open an issue and tell us.\nW3C VISS2 reference server A reference server written in Go for the VISSv2 specification can be found at https://github.com/w3c/automotive-viss2.\nKUKSA.val in-vehicle VISS server A VISS server written in C++, optimized for containerized deployments on vehicle computers is provided by the KUKSA project.\nIoT Event Analytics Plattform IoT Event Analytics is a Complex Event Processing platform for the Vehicle Edge. The IoTEA tooling can automatically import VSS an data model, and it can optionally use KUKSA.val to ingest live data from a vehicle.\nAOS The AOS platform can support VSS to access vehicle data.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/rule_set/instances/",
	"title": "Instances",
	"tags": [],
	"description": "",
	"content": "VSS resembles primarily the physical structure of the vehicle, so quite often there is a need to repeat branches and data entries (e.g. doors, axles, etc). To avoid hard-coded repetitions of branches and data entries in the specification an instance-concept is supported. Instances remove the need of repeating definitions, by defining at the node itself how often it occurs in the resulting tree. They are meant as a short-cut in the specification and interpreted by the tools.\nDefinition How can I create instances for my branch? An instance can be defined in any branch. The instantiation is done for every node in the following path. Instances are defined with the key-word instances, followed by its definition, which can be either: a list of strings, where each element defines a single instance, e.g. ['Left','Right'] results into two instances of every following data entry in the path, named Left and Right a string, followed by a range defined through [n,m], with n,m as integer and n \u0026lt;= m, which defines the number of instances. Position[1,4] results into 4 instances of every following data entry in the path, named Position1, Position2, Position3 and Position4. It is in VSS recommended to use 1 as start index for the first row/axle/position/\u0026hellip; If multiple instances occur in one node or on the path to a data entry, the instances get combined, by the order of occurrence. Following the example above, four position instances will be created for each of the \u0026lsquo;Left\u0026rsquo; and \u0026lsquo;Right\u0026rsquo; instances, resulting into a total number of 8 instances. How can I exclude child-nodes from instantiation? Often it makes sense to instantiate all child-nodes of a branch. But there are cases, when nodes are linked more the general concept of a branch, but not to the single instance. This could be the DoorCount, which would rather be Door.Count, WheelDiameter, which is rather linked to an axle rather than the wheel itself or Brake.FluidLevel which is not measured for a single break, but rather a system indication.\nTo exclude a child-node from the instantiation of the direct parent node, set the keyword instantiate to false (true by default). Please check the following example for details.\nExample The example from above in the specification:\n# Cabin.vspec Door: type: branch instances: - Row[1,4] - [\u0026#34;Left\u0026#34;,\u0026#34;Right\u0026#34;] description: All doors, including windows and switches #include SingleDoor.vspec Door Door.Count: datatype: uint8 type: attribute default: 4 instantiate: false description: Number of doors in vehicle. # SingleDoor.vspec # # Definition of a single door # IsOpen: datatype: boolean type: actuator description: Is door open or closed Results in the following dot-notated output:\nVehicle.Cabin.Door Vehicle.Cabin.Door.Count Vehicle.Cabin.Door.Row1 Vehicle.Cabin.Door.Row1.Left Vehicle.Cabin.Door.Row1.Left.IsOpen Vehicle.Cabin.Door.Row1.Right Vehicle.Cabin.Door.Row1.Right.IsOpen Vehicle.Cabin.Door.Row2 Vehicle.Cabin.Door.Row2.Left Vehicle.Cabin.Door.Row2.Left.IsOpen Vehicle.Cabin.Door.Row2.Right Vehicle.Cabin.Door.Row2.Right.IsOpen Vehicle.Cabin.Door.Row3 Vehicle.Cabin.Door.Row3.Left Vehicle.Cabin.Door.Row3.Left.IsOpen Vehicle.Cabin.Door.Row3.Right Vehicle.Cabin.Door.Row3.Right.IsOpen Vehicle.Cabin.Door.Row4 Vehicle.Cabin.Door.Row4.Left Vehicle.Cabin.Door.Row4.Left.IsOpen Vehicle.Cabin.Door.Row4.Right Vehicle.Cabin.Door.Row4.Right.IsOpen Redefinition It is possible to override the default instantiation provided by VSS by redefining the branch with different instantiation information. If multiple definitions of a branch exist with different instance definitions, then the last found definition will be used. As an example, if only two rows of doors are needed, then the default VSS instance definition can be overridden by redefining the Door branch as shown in the example below.\n#Redefinition changing number of rows from 4 to 2 #The redefinition must appear \u0026#34;after\u0026#34; the original definition Vehicle.Cabin.Door: type: branch instances: - Row[1,2] - [\u0026#34;Left\u0026#34;,\u0026#34;Right\u0026#34;] description: All doors, including windows and switches Recommendations VSS is designed to cover a wide range of vehicles. This means that the default instantiation used in VSS may not fit every vehicle. An example can be seen in the windshield signals defined in Body.vspec, parts of them are shown below. VSS offers the possibility to control windshield heating separately for front and rear windshield, and VSS also gives the possibility to report washer fluid level separately for each windshield. This fits very well for a vehicle that has separate washer fluid containers for front and rear windshield and that offers heating for both windshields. But that is not the case for all vehicles, it is not even certain that all vehicles have two windshields. This sections gives recommendations on how to use VSS for a vehicle if the VSS specification does not offer an exact match of the capabilities of the vehicle.\nWindshield: type: branch instances: [\u0026#34;Front\u0026#34;, \u0026#34;Rear\u0026#34;] description: Windshield signals Windshield.Heating: type: branch description: Windshield heater signals Windshield.Heating.Status: datatype: boolean type: actuator description: Windshield heater status. 0 - off, 1 - on Windshield.WasherFluid: type: branch description: Windshield washer fluid signals Windshield.WasherFluid.LevelLow: datatype: boolean type: sensor description: Low level indication for washer fluid. True = Level Low. False = Level OK. Recommendation: Instance Mismatch If a vehicle does not have as many instances as specified in VSS then one of the following methods are recommended:\nRedefine the branch. If a vehicle for example does not have a rear windshield then append a redefinition at the end of the VSS: Vehicle.Body.Windshield: type: branch instances: [\u0026#34;Front\u0026#34;] description: Windshield signals Accept that a branch Vehicle.Body.Windshield.Rear will exist in the generated VSS representation, use mechanisms outside VSS to ignore that branch Recommendation: Features shared among instances If a feature is shared among instances, it is recommended to publish that feature for all concerned instances.\nExample: In VSS washer fluid can be handled separately for front and rear windshield. If a vehicle use a common container serving both front and rear windshield, then it is recommended that the vehicle report information on that container in both Vehicle.Body.Windshield.Front.WasherFluid.LevelLow and Vehicle.Body.Windshield.Rear.WasherFluid.LevelLow.\nRecommendation: Features lacking for some instances Not all instances in a vehicle might have the same features. If e.g. the front windshield from the example above lack a heater, then it is recommended to use mechanisms outside VSS to ignore Vehicle.Body.Windshield.Front.Heating.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/rule_set/includes/",
	"title": "Includes",
	"tags": [],
	"description": "",
	"content": "An include directive in a vspec file will read the file it refers to and the contents of that file will be inserted into the current buffer in place of the include directive. The included file will, in its turn, be scanned for include directives to be replaced, effectively forming a tree of included files.\nSee Fig 6 for an example of such a tree.\nFig 6. Include directives\nThe include directive has the following format:\n#include \u0026lt;filename\u0026gt; [prefix] The \u0026lt;filename\u0026gt; part specifies the path, relative to the file with the #include directive, to the vspec file to replace the directive with.\nThe optional [prefix] specifies a branch name to be prepended to all signal entries in the included file. This allows a vspec file to be reused multiple times by different files, each file specifying their own branch to attach the included file to.\nAn example of an include directive is:\n#include doors.vpsec chassis.doors The door.vspec section specifies the file to include.\nThe chassis.doors section specifies that all signal entries in door.vspec should have their names prefixed with chassis.doors.\nIf an included vspec file has branch or signal specifications that have already been defined prior to the included file, the new specifications in the included file will override the previous specifications.\nREUSING SIGNAL TREES Complete subtrees of signals can be reused by including them multiple times, attaching them to different branches each time they are included.\nAn example is given in Fig 7 where a generic door signal specification is included four times to describe all doors in the vehicle.\nFig 7. Reusing signal trees\nThe door.vspec file is included four times by the master root.vspec file. The signals of door.vspec, Locked, WinPos, and Open are attached on the front left and right doors of row 1 (front) and row 2 (back).\nIf door.vspec is changed, the changes will be propagated to all four doors.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/rule_set/overlay/",
	"title": "Overlay",
	"tags": [],
	"description": "",
	"content": "VSS defines the standard catalog for vehicle signals independent of the used protocol and environment. In order to adopt the specification we realize that certain additions and modifications to the standard catalog are necessary. VSS Overlays are meant to bring you a standardized way of handling those changes.\nThe following features with the intended usage patterns are currently supported:\nAdding new nodes: By adding nodes the standard catalog can be extended with proprietary concepts. Changing the value of existing metadata: The standard catalog defines metadata based on what is assumed to be an average vehicle. Configurations may differ slightly (e.g. the instantiation of number of available seats), or special situations that require a (limited) modification of existing metadata. Adding new key/value pairs as additional metadata: Extending the model with richer information is a fundamental feature enabled by the layer concept. For example, deploying VSS into a specific scenario or with a particular binding/technology often needs some additional information. Multiple layer files: VSS layers can be split into several files in order to clearly separate concerns. Layering allows all the features above to be applied in a composable manner. In order to keep a determinstic result a clear order has to remain. Scenarios for using Overlays The standard catalog is specified within COVESA and defines a common view of the major attributes, sensors and actuators of vehicles. This is used in many different scenarios, protocols and environments. Additional meta data might be required for data-governance, -quality or -sources. The instantiation of branches might not fit your vehicle. Proprietary signals might be needed for extending the specification for your own use-cases. Up to now you were on your own in these scenarios. Overlays give you the chance to change and modify the standard catalog in a standardized way.\nHow does it work? Simply said, the tooling accepts, n additional spec files, next to the original specification file, which can overwrite or extend data in the VSS tree defined by the original specification.Before you start you should know:\nOverlay-files have to be valid specification files by themselves. In practice that means, that the path to a node has to be well defined. You can omit parent branches if there is no need to change them Tooling supports implicit branches. Order matters. The order on how the overlay files are called in the CLI command matters! An example is shown in the figure below. The Figure below illustrates an example of the main specification and two separate overlay files, an example call of the tooling and the resulting tree.\nFigure: Overview on how overlays work within VSS\n# In this overlay all parent branches are included. # That is not mandatory, as tooling supports implicit branches. Vehicle: type: branch Vehicle.Cabin: type: branch Vehicle.Cabin.NewBranch: #\u0026lt; introduction of a new branch type: branch description: \u0026#34;new test branch\u0026#34; Vehicle.Cabin.NewBranch.HasNewSignal: #\u0026lt; introduction of a new signal type: sensor description: \u0026#34;new test signal\u0026#34; datatype: int8 Vehicle.Cabin.Door: type: branch Vehicle.Cabin.Door.IsOpen: type: sensor #\u0026lt; change of node type datatype: boolean File: overlay_1.vspec\n# This overlay use implicit branches. # This means that tooling will either reuse the existing Vehicle.Cabin.NewBranch, # or if not found create it with default values. Vehicle.Cabin.NewBranch.HasNewAttribute: #\u0026lt; ...with a new attribute type: attribute description: \u0026#34;new test attribute\u0026#34; datatype: string Vehicle.Cabin.Door.IsOpen: type: sensor newKey: value #\u0026lt; Add a new key to the node and add a value datatype: boolean File: overlay_2.vspec\nOverlays in the standard catalog With the feature of overlays, we introduced a new folder in the repository called overlays. In there you\u0026rsquo;ll find two additional folders:\nprofiles: Larger overlays to adapt VSS to a specific vehicle category, like motorbikes. extensions: Smaller overlays typically to be applied after applying profiles (if any). DISCLAIMER: Use of overlays is a new concept for VSS. The overlays in those folders shall currently be seen as examples only, and are not part of the official VSS specification.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/rule_set/data_entry/data_types/",
	"title": "Data Types",
	"tags": [],
	"description": "",
	"content": "Each data entry specifies a datatype from the following set (from Franca IDL). Datatypes shall not be used in branch entry\nSupported datatypes Name Type Min Max uint8 unsigned 8-bit integer 0 255 int8 signed 8-bit integer -128 127 uint16 unsigned 16-bit integer 0 65535 int16 signed 16-bit integer -32768 32767 uint32 unsigned 32-bit integer 0 4294967295 int32 signed 32-bit integer -2147483648 2147483647 uint64 unsigned 64-bit integer 0 2^64 - 1 int64 signed 64-bit integer -2^63 2^63 - 1 boolean boolean value 0/false 1/true float floating point number -3.4e -38 3.4e 38 double double precision floating point number -1.7e -300 1.7e 300 string character string n/a n/a Arrays Besides the datatypes described above, VSS supports as well the concept of arrays, as a collection of elements based on the data entry definition, wherein it\u0026rsquo;s specified. By default the size of the array is undefined. By the optional keyword arraysize the size of the array can be specified. The following syntax shall be used to declare an array:\n# Array of datatype uint32, by default size of the array is undefined datatype: uint32[] # Optional: specified number of elements in the array arraysize: 5 An example for the usage of arrays is Vehicle.OBD.DTCList which contains a list of Diagnostic Trouble Codes (DTCs) present in a vehicle.\nStructs VSS struct support is further described on this page.\nTimestamps Timestamps are in VSS typically represented as strings, formatted according to ISO 8601. Timestamps shall be expressed in UTC (Coordinated Universal Time), with special UTC designator (\u0026ldquo;Z\u0026rdquo;). Time resolution SHALL at least be seconds, with subsecond resolution as an optional degree of precision when desired. The time and date format shall be as shown below, where the sub-second data and delimiter is optional.\nYYYY-MM-DDTHH:MM:SS.ssssssZ Data Streams Data Entries, which describe sensors offering binary streams (e.g. cameras), are not supported directly by VSS with a dedicated data type. Instead, they are described through the meta data about the sensor itself and how to retrieve the corresponding data stream.\nA camera can be a good example of it. The Data Entry for the camera and the corresponding video stream could look like:\nCamera: type: branch description: Information about the camera and how to connect to the video stream Camera.IsActive: type: actuator datatype: boolean description: If the camera is active, the client is able to retrieve the video stream Camera.URI: type: sensor datatype: string description: URI for retrieving the video stream, with information on how to access the stream (e.g. protocol, data format, encoding, etc.) In this example, it shows the usage of meta data about the status of the sensor. The camera can be set to active through the same data entry (actuator). A dynamic data entry (sensor) is used for the URI of the video stream. Information on how to access the stream is expected.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Introduction Discover what the Vehicle Signal Specification is all about.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/rule_set/data_entry/data_types_struct/",
	"title": "Struct Types",
	"tags": [],
	"description": "",
	"content": "COVESA is in the process of introducing struct support. It is a still an experimental feature, and information on this page may be incorrect, may change, or may not be supported by tooling yet!\nIntroduction VSS has historically supported only the following types:\nInteger-based types (e.g. uint8, int32) Float-based types (float, double) String Boolean In addition to this VSS arrays of the types given above has been supported. This has been considered insufficient for some use-cases. Typical examples are when something cannot be described by a single value, but multiple values are needed.\nA few hypothetical examples include:\nGPS locations, where latitude and longitude must be handled together Obstacles - where each obstacle may contain information like category, probability and location Errors/Warnings - where each item might contain information on category and priority as well as time stamp Based on this a syntax for supporting structs in VSS has been defined\nIntended usage The struct support in VSS is introduced to facilitate logical binding/grouping of data that originates from the same source. It is intended to be used only when it is important that the data is read or written in an atomic operation. It is not intended to be used to specify how data shall be packaged and serialized when transported.\nBy this reason VSS-project will not introduce smaller datatypes (like uint1,uint4) to enable bit-encoding of data. The order of elements in a struct is from a VSS perspective considered as arbitrary. The VSS project will by this reason not publish guidelines on how to order items in the struct to minimize size, and no concept for introducing padding will exist.\nStructs shall be used in VSS standard catalog only when considered to give a significant advantage compared to using only primitive types.\nStructs vs. Aggregate VSS supports a keyword aggregate that can be used on branches to indicate that the branch preferably shall be read and written in atomic operations. The keyword is however currently not used in the standard catalog, and it is not known if any implementation exists that actually consider it. There have been criticism that aggregate changes the semantic meaning of branches and signals, i.e. that a signal is no longer handed as an independent object. The exact meaning of aggregate is furthermore not well defined by VSS. Shall for example a write request (or update of sensor values) be rejected by an implementation if not all signals in the branch are updated in the same operation? Semantic interpretation is also ambiguous if the branch contains a mix of sensors, attributes and actuators. Using structs as datatype is better aligned with the view that VSS signals are independent objects, and the semantic ambiguities related to aggregate are not present for structs.\nAggregate could however be useful as information on deployment level. It gives the possibility to indicate that in this particular deployment the signals in the branch shall be treated as an aggregate. Exact meaning of the aggregate keyword is then deployment specific. With this view, aggregate shall never be used in the standard catalog, but can be used in overlays for deployment-specific purposes.\nGeneral Idea and Basic Semantics A signal of struct type shall be defined in the same way as other VSS signals, the only difference would be that instead of using a primitive type there shall be a reference to a struct datatype. This means that structs can be used for all types of VSS signals (i.e. sensor, attribute and actuator). If a signal of struct type is sent or received, VSS expects all included items to have valid values, i.e. all items are mandatory. For example, if a struct contains the items A, B and C - then it is expected that the sent signal contains value for all items. If some items are considered optional then the value range of the items must be adapted to include values indicating \u0026ldquo;not available\u0026rdquo; or \u0026ldquo;undefined\u0026rdquo;, or additional items needs to be added to indicate which items that have valid values.\nVSS makes no assumption on how structs are transferred or stored by implementations. It is however expected that they are read and written by atomic operations. This means that the data storage shall be \u0026ldquo;locked\u0026rdquo; while the items of the struct are read, preventing changes to happen while reading/writing the items.\nStructs shall be defined in a separate tree. This means that signal definitions and types cannot exist in the same files. Tooling must thus accept one (or more) parameters for specifying type definition(s)\nThe top level types file (e.g. vss_types.vspec) can refer to other type files similar to the top VSS file. Tooling may in the future support overlays for type declarations similar to how it is supported for signals.\nFor current vss-tools support for structs see documentation in the vss-tools repository.\nNaming Restrictions The VSS syntax and tooling shall not enforce any restrictions on naming for the type tree. It may even use the same branch structure as the signal tree. This means that it theoretically at the same time could exist both a signal A.B.C and a struct A.B.C. This is not a problem as it always from context is clear whether a name refers to a signal or a type.\nSimple Definition and Usage This could be a hypothetical content of a VSS type file\nTypes: type: branch Types.DeliveryInfo: type: struct description: A struct type containing info for each delivery Types.DeliveryInfo.Address: datatype: string type: property description: Destination address Types.DeliveryInfo.Receiver: datatype: string type: property description: Name of receiver This struct definition could then be referenced from the VSS signal tree\nDelivery: datatype: Types.DeliveryInfo type: sensor The type file may contain sub-branches and #include-statements just like regular VSS files\nTypes: type: branch Types.Powertrain: type: branch description: Powertrain types. #include Powertrain/Powertrain.vspec Types.Powertrain Name resolution Two ways of referring to a type shall be considered correct:\nIn Type Tree:\nReference by absolute path Reference by (leaf) name to a struct definition within the same branch In Signal Tree:\nReference by absolute path Reference by (leaf) name to a struct definition within a branch with the same name in the type tree. Note that the experimental feature supports only absolute path name resolution in the signal tree. Relative paths (e.g. ../Powertrain.SomeStruct) shall not be supported. Structs in parent branches will not be visible, in those cases absolute path needs to be used instead.\nThe reference by leaf name is applicable only for structs referencing other structs, and for the special case that the type branch has the same name/path as the signal branch!\nParsers shall first look for a matching type in a branch with the same name, and if not found consider the name given to be an absolute name.\nExample:\nA.B.C: datatype: Types.D type: sensor The parser shall first check if a type A.B.Types.D exist in the type tree, and if so use it. If not found it shall search for the type Types.D in the type tree. Note that the experimental feature supports only exact name resolution in the signal tree.\nExpectations on VSS implementations (e.g. VISS, KUKSA.val) It is expected of implementations to support atomic read/write/subscribe of complete signals defined with struct datatype. They may support read of parts of signal, e.g. DeliveryList.Receiver\nArray Support It is allowed to use a struct type in an array\nDeliveryList: datatype: Types.DeliveryInfo[] type: sensor description: List of deliveries By default the array has an arbitrary number of element and may be empty. If a fixed size array is wanted the keyword arraysize can be used to specify size:\nDeliveryList: datatype: Types.DeliveryInfo[] arraysize: 5 type: sensor description: List of deliveries Expectations on VSS implementations (e.g. VISS, KUKSA.val) For array types (like above) VSS implementations may support several mechanisms\nIt is expected that they can support read/write/subscribe of the whole array, i.e. write all or read all in the same request They may optionally support additional operations like Writing/Reading a single instance, e.g. DeliveryList[2] (index mechanism is implementation dependent) Appending/Deleting individual instances Searching for instances with specific conditions. Structure in Structure It is allowed to refer to a structure type from within a structure\nOpenHours: type: struct description: A struct type containing information on open hours OpenHours.Open: datatype: uint8 type: property max: 24 description: Time the address opens OpenHours.Close: datatype: uint8 type: property max: 24 description: Time the address close DeliveryInfo: type: struct description: A struct type containing info for each delivery DeliveryInfo.Address: datatype: string type: property description: Destination address DeliveryInfo.Receiver: datatype: string type: property description: Name of receiver DeliveryInfo.Open: datatype: OpenHours type: property description: When is receiver available Order of declaration/definition The order of declaration/definition shall not matter. As signals and types are defined in different trees this is a topic only for struct definitions referring to other struct definitions. A hypothetical example is shown below. An item in the struct DeliveryInfo can refer to the struct OpenHours even if that struct is defined further down in the same file.\nDeliveryInfo: type: struct description: A struct type containing info for each delivery ... DeliveryInfo.Open: datatype: OpenHours type: property description: When is receiver available OpenHours: type: struct description: A struct type containing information on open hours ... Inline Struct Inline/anonymous structs shall not be supported!\nDefault Values VSS supports default values for attributes, and there is a discussion to allow it also for sensors/actuators.\nDefault values are not supported for signals of struct type. This also mean that VSS does not need to specify notation for struct values. An exception is arrays of struct-types, where \u0026ldquo;empty array\u0026rdquo;, i.e. [] shall be supported as default value.\nIt shall be possible to define default values for properties (unless the item is of struct type). If all items of a struct type have default values, then a signal (or item) using the struct type is also considered to have a default value.\nAllowed Values VSS supports specification of allowed values. As of today it is theoretically supported for all datatypes, but there is an issue discussing if it is to be supported only for string data and possible integer-based types.\nUsing allowed for type: property is allowed (if allowed is supported for the used datatype). Using allowed for signals and items of struct type or array of struct type is not allowed.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/governance/",
	"title": "Governance",
	"tags": [],
	"description": "",
	"content": "Governance The Vehicle Signal Specification (VSS) project is an initiative by COVESA to define a syntax and a catalog for vehicle signals.\nThe artifacts maintained by the VSS project consist of:\nSource code, documentation and releases in the VSS github repository. Tools for parsing and converting VSS files in the VSS-tools github repository. The VSS project has an informal structure with a chair and github maintainers appointed by COVESA. Tasks for the chair includes hosting regular meeting to discuss incoming pull requests and issues, as well as roadmap and release planning.\nContribution process Anyone may propose changes to VSS. It is up to the VSS project to decide if the changes are feasible to include in VSS. The VSS project does not have any developers or maintainers paid by COVESA. Instead, the VSS project relies on voluntary contributions, typically from member organizations. The maintainers are expected to review incoming pull requests. All contributions must follow the COVESA contribution guidelines.\nIn general, pull requests shall be opened for at least a week before being merged to give time for COVESA members to review the pull request and provide comments. In case of larger changes or changes that affect backward compatibility pull requests are typically opened for a longer period, to allow for a through review. Pull requests, unless trivial, are typically merged first after a decision at one of the regular VSS meetings, see link at COVESA VSS wiki page. These rules concerns primarily normative content (see below), non-normative content may be updated without thorough reviews.\nFor more information and guides on how to contribute see CONTRIBUTING.md.\nBranches VSS development is typically developed in the master branch only. Each release is tagged and a maintenance branch is created (e.g. release/3.0) which could be used as target for pull requests intending to patch a release.\nNormative vs. non-normative content The VSS repositories contain some artifacts that can be considered normative, i.e. an implementation claiming to \u0026ldquo;support\u0026rdquo; VSS shall:\nSupport signals defined according to the rules in the VSS documentation (source, generated) Support the signals currently defined in VSS. The signals in source format (*.vspec files) can be found in Github repository. Derived formats supported by VSS project are included in each release, originating from the tools in the VSS-tools github repository. In addition to this the VSS repositores contain artifacts that currently are considered non-normative. This includes immature concepts and work-in progress. Non-normative content include:\nVSS Github Wiki VSS Tools Wiki Overlays and Profiles Contributed tools The list of what is considered normative and non-normative is no static, it may change over time.\nHandling of backward compatibility The VSS project aims to keep backward compatibility as far as feasible. VSS is however an evolving syntax and catalog and there are still areas where changes are need to fit the need of users. Changes that breaks backward compatibility are typically introduced only in major releases (e.g. X.0) and shall be documented in release notes. This concerns changes to syntax and signals, but also to tools.\nThe VSS project has introduced a deprecation concept. If possible, when e.g. renaming or moving a signal or changing tools the old signal or parameter set shall be kept but marked as deprecated. That allows the change to be introduced in a minor version (e.g. X.Y). The old signal shall be removed first in the next major release, or later if needed.\nA history of past changes and planned changes that affects backward compatibility can be found in the Changelog.\nRelease Process The release process is further described in the Github repository.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/rule_set/",
	"title": "Rule Set",
	"tags": [],
	"description": "",
	"content": "Rule Set The Rule Set of a domain taxonomy is used to describe how to write the data definition syntactically.\nThis chapter defines and describes the rule set for VSS. Tools in the vss-tools repository can be used to validate that a specification follows the rule set for VSS, but those tools may have limitations and may not check all rules stated in this document. In case of conflict, what is stated in the rule set in this documentation is considered to have precedence over tool implementations.\nVersion handling The source for the rule set is in VSS Git repository. The online version of the rule set in the generated VSS documentation is updated whenever a new commit is merged to the VSS master branch and does this not necessarily correspond to the rule set for the last release VSS version.\nTo highlight important changes to the VSS rule set two notations are used in the documen\nsince version X.Y means that the concept/syntax was introduced in version X.Y. Older tools not supporting VSS version X.Y may not support this concept/syntax. deprecated since version X.Y means that the concept/syntax is no longer recommended from version X.Y onwards. The concept/syntax may be removed in the next major release. "
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/rule_set/data_entry/data_unit_types/",
	"title": "Data Unit Types",
	"tags": [],
	"description": "",
	"content": "Introduction to Data Unit Types in VSS It is in VSS possible for signals to specify a unit of measurement from a list of predefined data unit types. For most signals in the VSS standard catalog, a data unit type has been selected. A typical example is Vehicle.Speed, as shown below.\nVehicle.Speed: datatype: float type: sensor unit: km/h description: Vehicle speed. The ambition when selecting data unit types for signals in VSS standard catalog has been to use either a unit based on SI-units, or a unit commonly used within the vehicle industry. For the Vehicle.Speed example above this means that km/h has been selected, even if m/s from an SI-perspective would have been a better choice.\nIt must be noted that the selected unit does not imply that the value of Vehicle.Speed always needs to be sent or visualized as km/h (with float as datatype). A user interface or API may show or request vehicle speed in any unit it likes, and a transport protocol may send speed in another unit, possibly also involving scaling and offset. But in protocols not explicitly specifying data unit types (like VISS) it is expected that Vehicle.Speed is sent and received as km/h (without scaling or offset).\nIn some cases it is natural to omit the data unit type. This concerns typically signals where data type string is used, but also signals where the value just represents a number, like in the example below:\nVehicle.Cabin.DoorCount: datatype: uint8 type: attribute default: 4 description: Number of doors in vehicle. Logical Data Unit Types VSS supports percent as data unit type, typically with 0 to 100% as the allowed range. In some cases, the definition on how to calculate the signal value is obvious, like for Vehicle.Powertrain.FuelSystem.Level below. It is likely that all VSS users will calculate fuel level in the same way, i.e. the meaning of a fuel level of 50% is well agreed, the liters of fuel in the tank is exactly 50% of nominal capacity.\nVehicle.Powertrain.FuelSystem.Level: datatype: uint8 type: sensor unit: percent min: 0 max: 100 description: Level in fuel tank as percent of capacity. 0 = empty. 100 = full. In other cases, the formula for calculating the signal is not obvious and is not specified in VSS. A typical example is shown below for clutch wear. While most VSS users likely can agree that a brand new clutch shall have 0 as \u0026ldquo;ClutchWear\u0026rdquo;, the exact formula for calculating clutch wear for a used clutch will likely be vehicle specific. Some vehicles might monitor actual wear, others might estimate it based on vehicle usage. This is in VSS called a logical range, a VSS user knows what range to use but are free to define the formula for calculating the value. Values from different vehicles (of different make/model) can not always be compared, as the formula used for calculation may differ.\nVehicle.Powertrain.Transmission.ClutchWear: datatype: uint8 type: sensor unit: percent max: 100 description: Clutch wear as percent. 0 = no wear. 100 = worn. List of supported Data Unit Types This list composed with definition according to International Units (SI) and few automotive specific units: Specification, Wikipedia\nUnit type Domain Description mm Distance Distance measured in millimeters cm Distance Distance measured in centimeters m Distance Distance measured in meters km Distance Distance measured in kilometers inch Distance Distance measured in inches km/h Speed Speed measured in kilometers per hours m/s Speed Speed measured in meters per second m/s^2 Acceleration Acceleration measured in meters per second squared cm/s^2 Acceleration Acceleration measured in centimeters per second squared ml Volume Volume measured in milliliters l Volume Volume measured in liters cm^3 Volume Volume measured in cubic centimeters celsius Temperature Temperature measured in degree celsius degrees Angle Angle measured in degrees degrees/s Angular Speed Angular speed measured in degrees per second W Power Power measured in watts kW Power Power measured in kilowatts PS Power Power measured in horsepower kWh Energy Consumption Energy consumption measured in kilowatt hours g Weight Mass measured in grams kg Weight Mass measured in kilograms lbs Weight Mass measured in pounds V Electric Potential Electric potential measured in volts A Electric Current Electric current measured in amperes Ah Electric Charge Electric charge measured in ampere hours ms Time Time measured in milliseconds s Time Time measured in seconds min Time Time measured in minutes h Time Time measured in hours day Time Time measured in days weeks Time Time measured in weeks months Time Time measured in months years Time Time measured in years UNIX Timestamp Time Unix time is a system for describing a point in time. It is the number of seconds that have elapsed since the Unix epoch, excluding leap seconds. mbar Pressure Pressure measured in millibars Pa Pressure Pressure measured in pascal kPa Pressure Pressure measured in kilopascal stars Rating Rating measured in stars g/s Mass per time Mass per time measured in grams per second g/km Mass per distance Mass per distance measured in grams per kilometers kWh/100km Energy Consumption per distance Energy consumption per distance measured in kilowatt hours per 100 kilometers ml/100km Volume per distance Volume per distance measured in milliliters per 100 kilometers l/100km Volume per distance Volume per distance measured in liters per 100 kilometers l/h Flow Flow measured in liters per hour mpg Distance per Volume Distance per volume measured in miles per gallon N Force Force measured in newton Nm Torque Torque measured in newton meters rpm Rotational Speed Rotational speed measured in revolutions per minute Hz Frequency Frequency measured in hertz ratio Relation Relation measured as ratio percent Relation Relation measured in percent \u0026hellip; \u0026hellip; \u0026hellip; VSS tooling use the list specified in config.yaml to validate that only supported types are used in the signal specification.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/rule_set/data_entry/sensor_actuator/",
	"title": "Sensors &amp; Actuators",
	"tags": [],
	"description": "",
	"content": "Sensors are signals to read values of properties in a vehicle. Values of sensors typically change over time. Reading a sensor shall return the current actual value of the related property, e.g. the current speed or the current position of the seat.\nActuators are used to control the desired value of a property. Some properties in a vehicle cannot change instantly. A typical example is position of a seat or a window. Reading a value of an actuator shall return the current actual value, e.g. the current position of the seat, rather than the wanted/desired position. A typical example could be if someone wants to change the position of a seat from 0 to 100. This can be changed by setting the corresponding actuator to 100. If the actuator is read directly after the set request it will still return 0 as it might take some seconds before the seat reaches the wanted position of 100. If the seat by some reason is blocked or cannot be moved due to safety reasons it might never reach the wanted position. It is up to the vehicle to decide how long time it shall try to reach the desired value and what to do if it needs to give up.\nA data entry for a sensor or actuator defines its members. A data entry example is given below:\nSpeed: type: sensor description: The vehicle speed. comment: For engine speed see Vehicle.Powertrain.CombustionEngine.Engine.Speed. datatype: float unit: km/h min: 0 max: 300 Drivetrain.Transmission.Speed Defines the dot-notated name of the data entry. Please note that all parental branches included in the name must be defined as well.\ntype Defines the type of the node. This can be branch, sensor, actuator or attribute.\ndatatype The string value of the type specifies the scalar type of the data entry value. See data type chapter for a list of available types.\ndescription Describes the meaning and content of the signal. The descriptionshall together with other mandatory members like datatype and unit provide sufficient information to understand what the signal contains and how signal values shall be constructed or interpreted. Recommended to start with a capital letter and end with a dot (.).\ncomment [optional] since version 3.0 A comment can be used to provide additional informal information on a signal. This could include background information on the rationale for the signal design, references to related signals, standards and similar. Recommended to start with a capital letter and end with a dot (.).\nmin [optional] The minimum value, within the interval of the given type, that the data entry can be assigned. If omitted, the minimum value will be the \u0026ldquo;Min\u0026rdquo; value for the given type. Cannot be specified if allowed is defined for the same data entry.\nmax [optional] The maximum value, within the interval of the given type, that the data entry can be assigned. If omitted, the maximum value will be the \u0026ldquo;Max\u0026rdquo; value for the given type. Cannot be specified if allowed is defined for the same data entry.\nunit [optional] The unit of measurement that the data entry has. See Unit Type chapter for a list of available unit types. This cannot be specified if allowed is defined as the signal type.\nsensor [optional] deprecated since version 3.1 The sensing appliance used to produce the data entry.\nThe VSS signal metadata attributes sensor and actuator are no longer considered part of the core VSS syntax If needed, they shall be used as additional metadata, see overlays\nactuator [optional] deprecated since version 3.1 The actuating appliance consuming the data entry.\nThe VSS signal metadata attributes sensor and actuator are no longer considered part of the core VSS syntax If needed, they shall be used as additional metadata, see overlays\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/license/",
	"title": "License",
	"tags": [],
	"description": "",
	"content": " DISCLAIMER: The following information about open source licensing shall not be considered legal advice. For advice on licensing, COVESA suggests that you contact your open source officer or legal counsel.\nWhich license applies VSS as well as the VSS-tools are covered by the Mozilla Public License 2.0 (MPL-2.0). The MPL-2.0 is an OSI approved Open Source license that gives you a lot of freedom using VSS in your products, or for (academic) research. It also provides a solid legal framework if you choose to contribute to either the standards or the tools.\nWe will line out some answers to commonly asked questions, but keep in mind this page is informational. The legally binding clauses can be found in the license itself. If in doubt, consult your friendly neighborhood lawyer or IP department.\nCan I use VSS / VSS-tools in my commercial products Most definitely yes. You must inform your users that the product contains MPLed code and need to provide access to the source (e.g. by linking to this documentation or our Github repository).\nI modified VSS-tools, do I need to give away my source? If you use the code internally within your organisation (company), you have no obligations to do so. (see also Q5 here). If you distribute the modified vss-tools outside your organization (e.g. to your customers), you need to make the source code of the MPL-2.0 licensed parts available. However, the MPL has only a very weak copyleft effect. As a rule of thumb: You have no obligation to provide code in new files. You have the obligation to make code of changed existing MPLed files available under the clauses pof the MPL-2.0, if you distribute them in source or compiled form outside your organisation ((see also Q9,10,11 here)).\nIn any case we do recommend you to consider sharing generally useful improvements with the community. Not only will you win karma points with the community and gain visibility as an innovation leader in the automotive industry, you will most likely also get more robust software as you will have more users and testers.\nI changed VSS or added custom signals to the standard catalog. Do I need to give them away? No. One important selling point of VSS is, that you can always extend the standard catalog with your own use case specific signals. There is no obligation to release any added signals or proprietary information to third parties.\nFrom an MPL-2.0 point of view the information of the previous question applies. To be extra sure, put any additions in separate files, and use the layering approach to modify the standard catalog. This community does not consider deleting elements from the standard catalog or adding VSS #include statements \u0026ldquo;modifications\u0026rdquo; in the sense of clause 1.10 of the MPL-2.0.\nAs with the tools, we do recommend you to consider sharing generally useful standard catalog improvements with the community.\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/ecosystem/",
	"title": "Ecosystem",
	"tags": [],
	"description": "",
	"content": "Tools VSS can be used in various systems. This section will give some pointers to the wider VSS ecosystem\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/rule_set/data_entry/attributes/",
	"title": "Attributes",
	"tags": [],
	"description": "",
	"content": "An attribute is an entity that has a default value, specified by its default member. The standard Vehicle Signal Specification does not include default values for all attributes. If a default value has not been specified then the OEM must define a default value matching the actual vehicle. If the standard defines a default value but it does not fit the actual vehicle, then the OEM must override the standard default value.\nAttribute values can also change, similar to sensor values. The latter can be useful for attribute values that are likely to change during the lifetime of the vehicle. However, attribute values should typically not change more than once per ignition cycle, or else it should be defined as a sensor instead.\nBelow is an example of a complete attribute describing engine power\nMaxPower: datatype: uint16 type: attribute default: 0 unit: kW description: Peak power, in kilowatts, that engine can generate. It is possible to give default values also for arrays. In this case square brackets shall be used. The value for each element in the array shall be specified. The size of the array is given by the number of elements specified within the square brackets.\nExample 1: Empty Array\ndefault: [] Example 2: Array with 3 elements, first element has value 1, second element value 2, third element value 0\ndefault: [1, 2, 0] Full example, array with two elements, first with value2, second with value 3:\nSeatPosCount: datatype: uint8[] type: attribute default: [2, 3] description: Number of seats across each row from the front to the rear Using default values for structs is not allowed!\n"
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/rule_set/data_entry/allowed/",
	"title": "Value restrictions",
	"tags": [],
	"description": "",
	"content": "Specifying allowed values Optionally it is possible to define an array of allowed values, which will restrict the usage of the data entry in the implementation of the specification. It is expected, that any value not mentioned in the array is considered an error and the implementation of the specification shall react accordingly. The datatype of the array elements is the datatype defined for the data entry itself. For attributes it is possible to optionally set a default value.\nSteeringWheel.Position: datatype: string type: attribute default: \u0026#39;FRONT_LEFT\u0026#39; allowed: [\u0026#39;FRONT_LEFT\u0026#39;, \u0026#39;FRONT_RIGHT\u0026#39;] description: Position of the steering wheel on the left or right side of the vehicle. If allowed is set, min or max cannot be defined.\nThe allowed element is an array of values, all of which must be specified in a list. Only values can be assigned to the data entry, which are specified in this list.\nThe datatype specifier gives the type of the individual elements of the allowed list.\nRecommendation on String values For string values used for default and allowed statements it is recommended to start with A-Z and then use only A-Z, 0-9 and underscore (_). It is recommended to use single quotes (') as tooling otherwise might handle literals like OFF as boolean values with unexpected result. It is recommended not to specify a dedicated value corresponding to \u0026ldquo;unknown\u0026rdquo; or \u0026ldquo;undefined\u0026rdquo; unless there is a relevant use-case for that particular signal. The background is that a signal with an array of allowed values shall be handled just as any other signal. If e.g. the value of current speed or vehicle weight is unknown, then the vehicle shall not publish the corresponding signal. Similarly, for the example above, if the steering wheel position is unknown then SteeringWheel.Positionshall not be published.\nAllowed values for array types The allowed keyword can also be used for signals of array type. In that case, allowed specifies the only valid values for array elements. The actual value of the signal is expected to contain a subset of the values specified in allowed.\nExample:\nDogBreeds: datatype: string[] type: attribute allowed: [\u0026#39;AKITA\u0026#39;, \u0026#39;BOXER\u0026#39;, \u0026#39;DACHSHUND\u0026#39;, \u0026#39;PAPILLON\u0026#39;, \u0026#39;PUG\u0026#39;, \u0026#39;VIZSLA\u0026#39;] description: Brief list of dog breeds. Examples of valid arrays:\n[] # Empty array [\u0026#39;BOXER\u0026#39;] [\u0026#39;PAPILLON\u0026#39;, \u0026#39;VIZSLA\u0026#39;, \u0026#39;BOXER\u0026#39;, \u0026#39;AKITA\u0026#39;, \u0026#39;DACHSHUND\u0026#39;] [\u0026#39;PUG\u0026#39;, \u0026#39;PUG\u0026#39;] # duplication is allowed Example of an invalid array:\n[\u0026#39;PAPILLON\u0026#39;, \u0026#39;VIZSLA\u0026#39;, \u0026#39;LOBSTER\u0026#39;] # LOBSTER is not in the allowed value list "
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/",
	"title": "Vehicle Signal Specification",
	"tags": [],
	"description": "",
	"content": "Vehicle Signal Specification The Vehicle Signal Specification (VSS) is an initiative by COVESA to define a syntax and a catalog for vehicle signals. The source code and releases can be found in the VSS github repository. Some tools for parsing and converting VSS files can be found in the VSS-tools github repository.\nThis documentation gives you an overview of VSS:\nIntroduction Read this part if you want to know more about what the specification is all about, what\u0026rsquo;s in and out and how to quickly browse through the current status. Governance Introduction to VSS governance model and change log. Rule Set Get familiar with the rule set behind the specification, the structure, the format and concepts. License Information on the VSS license. Ecosystem How to use the specification? Check out the existing tools and standards to transform or make use of VSS. "
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://covesa.github.io/vehicle_signal_specification/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]